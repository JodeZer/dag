# 泛型 API 基准测试报告

## 测试环境

```
goos: darwin
goarch: arm64
pkg: github.com/JodeZer/dag
cpu: Apple M4 Pro
```

## 性能对比

### 序列化性能（1365 个顶点的 DAG）

| 基准测试 | 操作耗时 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) | 相对性能 |
|---------|------------------|------------------|---------------------|----------|
| `MarshalJSON` (旧版) | 615,194 | 663,834 | 5,456 | 基准 (1x) |
| `MarshalJSON_Generic_String` | 767,417 | 1,306,684 | 9,564 | 1.25x 慢 |
| `MarshalJSON_Generic_Complex` | 872,583 | 1,347,982 | 9,564 | 1.42x 慢 |

### 反序列化性能（1365 个顶点的 DAG）

| 基准测试 | 操作耗时 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) | 相对性能 |
|---------|------------------|------------------|---------------------|----------|
| `UnmarshalJSON` (旧版) | 526,644 | 297,530 | 2,253 | 基准 (1x) |
| `UnmarshalJSON_Generic_String` | 112,146,323 | 168,248,883 | 65,325 | **213x 慢** |
| `UnmarshalJSON_Generic_Complex` | 152,443,777 | 168,306,690 | 65,326 | **289x 慢** |

### 大规模图性能（100,000 个顶点的 DAG）

| 基准测试 | 操作耗时 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) |
|---------|------------------|------------------|---------------------|
| `UnmarshalJSON_100k_3Branch` | 53,929,360 | 33,847,269 | 200,063 |
| `UnmarshalJSON_100k_4Branch` | 51,617,095 | 33,847,268 | 200,063 |
| `UnmarshalJSON_100k_5Branch` | 51,801,171 | 33,847,265 | 200,063 |

## 性能分析

### 为什么泛型 API 更慢？

泛型版本的性能损失主要来自以下方面：

1. **内存分配增加**：泛型版本分配的内存是旧版的约 29 倍（65,325 vs 2,253）
2. **类型转换开销**：每个 `storableVertexGeneric[T]` 的 `Vertex()` 方法返回 `(string, interface{})`，导致值装箱
3. **批量操作失效**：旧版使用 `addVerticesBatch` 批量添加顶点，而泛型版本需要额外的分配和接口转换

### 分配次数差异分析

| 组件 | 旧版 | 泛型版 | 差异 |
|------|------|--------|------|
| 顶点存储 | ~1,365 | ~1,365 | 相同 |
| 边存储 | ~888 | ~1,364 | ~1.5x |
| 接口转换 | 0 | ~64,000 | 主要开销 |

**关键发现**：分配次数差异主要来自 `Vertices()` 方法的实现，该方法将 `[]storableVertexGeneric[T]` 转换为 `[]Vertexer`，导致了大量的临时内存分配。

### 根本原因

DAG 的内部存储架构使用 `interface{}`：

```go
type DAG struct {
    vertices map[interface{}]string   // 存储的是 interface{}
    vertexIds map[string]interface{}   // 存储的是 interface{}
    // ...
}
```

这意味着无论使用什么 API，所有值最终都必须存储为 `interface{}`。泛型 API 的性能问题主要来自：

1. **序列化时的类型转换**：`MarshalGeneric[T]` 需要将 DAG 中存储的 `interface{}` 转换为类型 `T`
2. **反序列化时的接口转换**：`storableDAGGeneric[T].Vertices()` 将 `[]storableVertexGeneric[T]` 转换为 `[]Vertexer`

## 优化建议

### 当前实现的状态

**泛型 API 提供了更好的开发体验，但性能不如旧版 API。**

| 方面 | 旧版 API | 新泛型 API |
|------|---------|-----------|
| 序列化性能 | 基准 | ~1.3x 慢 |
| 反序列化性能（类型一致） | 基准 | **200x+ 慢** |
| 开发复杂度 | 高（需定义结构体） | 低（一行代码） |
| 类型安全 | ❌ | ✅ |

### 使用建议

**推荐使用泛型 API 的场景**：
- 开发阶段 / 原型开发
- 数据量较小（< 1000 顶点）
- 开发效率优先于运行时性能

**推荐使用旧版 API 的场景**：
- 生产环境
- 数据量大（> 1000 顶点）
- 性能敏感场景
- 需要处理混合类型数据

### 未来优化方向

要实现真正的高性能泛型 API，需要以下任一方案：

1. **创建全新的类型化 DAG 结构**（破坏性变更）
   - 修改 DAG 内部存储为泛型类型
   - 不兼容现有 API

2. **代码生成**（无破坏性）
   - 为每种类型生成专用代码
   - 类似于 protobuf 的代码生成

3. **接受当前权衡**
   - 保留泛型 API 用于开发便利
   - 旧版 API 用于生产环境

## 基准测试命令

```bash
# 运行所有序列化基准测试
go test -bench=BenchmarkMarshal -benchmem -run=^$ ./...

# 运行所有反序列化基准测试
go test -bench=BenchmarkUnmarshal -benchmem -run=^$ ./...

# 运行泛型配对基准测试
go test -bench='BenchmarkMarshalJSON_Generic|BenchmarkUnmarshalJSON_Generic' -benchmem -run=^$ ./...
```

## 结论

**泛型 API 的实现无法在不破坏现有 API 架构的情况下达到旧版 API 的性能。**

这是一个典型的**开发体验 vs 运行时性能**的权衡。泛型 API 提供了：
- ✅ 简洁易用的 API
- ✅ 类型安全
- ✅ 编译时检查

但在运行时性能上有显著的损失。

**最终建议**：
- **新项目 / 原型**：使用泛型 API 提高开发效率
- **生产环境 / 大数据量**：使用旧版 API 获得最佳性能
- **混合场景**：根据数据量和使用场景选择合适的 API